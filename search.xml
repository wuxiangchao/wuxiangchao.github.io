<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Attention is all your need论文阅读</title>
    <url>/2024/12/19/Attention-is-all-your-need%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Bundle Ajustment从理论到实践</title>
    <url>/2024/12/22/Bundle-Ajustment%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="Bundle-Ajustment光束平差法概述"><a href="#Bundle-Ajustment光束平差法概述" class="headerlink" title="Bundle-Ajustment光束平差法概述"></a>Bundle-Ajustment光束平差法概述</h1><span id="more"></span>
<h2 id="BA基本理论"><a href="#BA基本理论" class="headerlink" title="BA基本理论"></a>BA基本理论</h2><p>这是光束平差法</p>
<script type="math/tex; mode=display">
y=x+1</script><p>测试代码</p>
<script type="math/tex; mode=display">
\begin{equation} 
    \frac{1}{2} = \int_{1}^{2}\Sigma a_{ij} \cdot b_{ij} 
\end{equation}\label{1.1}</script><script type="math/tex; mode=display">\begin{equation}
\begin{bmatrix}
a & b \\
c & d
\end{bmatrix}
\end{equation}</script><h2 id="C-实现光束平差法"><a href="#C-实现光束平差法" class="headerlink" title="C++实现光束平差法"></a>C++实现光束平差法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 泛型编程</title>
    <url>/2024/12/19/C-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>这是一篇关于c++泛型编程的文章</p>
<span id="more"></span>
<p>Test</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 源码趣读 - 01</title>
    <url>/2024/12/22/Linux-%E6%BA%90%E7%A0%81%E8%B6%A3%E8%AF%BB-01/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 源码趣读 - 02</title>
    <url>/2024/12/22/Linux-%E6%BA%90%E7%A0%81%E8%B6%A3%E8%AF%BB-02/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 所有权机制</title>
    <url>/2024/12/19/Rust-%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>通过这篇博客深刻理解Rust的所有权机制</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><span id="more"></span>]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>《你当像鸟飞向你的山》读书笔记</title>
    <url>/2024/12/19/%E3%80%8A%E4%BD%A0%E5%BD%93%E5%83%8F%E9%B8%9F%E9%A3%9E%E5%90%91%E4%BD%A0%E7%9A%84%E5%B1%B1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 基本数据类型</title>
    <url>/2024/12/19/Rust-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Rust-基本数据类型概述"><a href="#Rust-基本数据类型概述" class="headerlink" title="Rust 基本数据类型概述"></a>Rust 基本数据类型概述</h1><p>Rust 每个值都有确切的数据类型, 总的来说可以分为两类: 借本类型和复合类型。基本类型意味着它们往往是一个最小化原子类型，无法结构为其它类型。</p>
<span id="more"></span>
<p>一般来说Rust包含以下基本类型:</p>
<ul>
<li>数值类型: 有符号整数(<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、无符号整数(<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>)</li>
<li>字符串: 字符串字面量和字符串切片 <code>&amp;str</code></li>
<li>布尔类型: <code>true</code> 和 <code>false</code></li>
<li>字符类型: 表示单个Unicode字符，存储为四个字节</li>
<li>单元类型: 即<code>()</code>, 其唯一的值也是()</li>
</ul>
<h1 id="类型推导与标注"><a href="#类型推导与标注" class="headerlink" title="类型推导与标注"></a>类型推导与标注</h1><p>与Python、JavaScript等动态语言不同，Rust是一门静态类型语言，也就是编译器必须再编译期知道所有变量的类型，但这不意味着你需要为每个变量指定类型，<br>因为<strong>Rust编译器可以根据变量值和上下文的使用方式来自动推导出变量的类型</strong>，但在某些情况下，它无法推导出变量类型，需要手动去给与一个类型标注。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span> = <span class="string">"32"</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">except</span>(<span class="string">"Not a number"</span>)</span><br></pre></td></tr></table></figure>
<p>上述代码编译器无法推导出想要的类型，编译器给出如下报错:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[Running] cargo run -q --release <span class="string">"i:\SourceCode\Rust\data_deep\src\main.rs"</span></span><br><span class="line">error[E0284]: <span class="keyword">type</span> <span class="title class_">annotations</span> needed</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">2</span>:<span class="number">9</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |     <span class="keyword">let</span> <span class="variable">guess</span> = <span class="string">"32"</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">"not a number"</span>);</span><br><span class="line">  |         ^^^^^        ----- <span class="keyword">type</span> <span class="title class_">must</span> be known at this point</span><br><span class="line">  |</span><br><span class="line">  = note: cannot satisfy `&lt;_ <span class="keyword">as</span> FromStr&gt;::<span class="literal">Err</span> == _`</span><br><span class="line">help: consider giving `guess` an explicit <span class="keyword">type</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |     <span class="keyword">let</span> <span class="variable">guess</span>: <span class="comment">/* Type */</span> = <span class="string">"32"</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">"not a number"</span>);</span><br><span class="line">  |              ++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0284`.</span><br><span class="line">error: could not compile `data_deep` (bin <span class="string">"data_deep"</span>) due to <span class="number">1</span> previous error</span><br><span class="line"></span><br><span class="line">[Done] exited with code=<span class="number">101</span> <span class="keyword">in</span> <span class="number">0.605</span> seconds</span><br></pre></td></tr></table></figure>
<p>正确的写法应该是:<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">i32</span> = <span class="string">"32"</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">except</span>(<span class="string">"Not a number"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><blockquote>
<p>Rust使用一种相对传统的语法来创建整数<code>(1, 2, ...)</code>和浮点数<code>(1.0, 1.1, ...)</code>.</p>
</blockquote>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整数是没有小数的数字，<code>i</code>是<code>integer</code>的首字母，<code>u</code>是<code>unsigned</code>的首字母</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号整形</th>
<th>无符号整形</th>
</tr>
</thead>
<tbody>
<tr>
<td>8位</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16位</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32位</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64位</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128位</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>视架构而定</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody>
</table>
</div>
<p>类型定义的形式统一为:<code>i(u)+类型位数</code>。<strong>无符号数</strong>表示只能取正整数和0，而<strong>有符号数</strong>则表示数字可以取正整数、负整数和0。</p>
<blockquote>
<p>每个有符号类型规定的数字范围是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="17.321ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 7655.9 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(778,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1378,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2966.7,0)"><path data-c="223C" d="M55 166Q55 241 101 304T222 367Q260 367 296 349T362 304T421 252T484 208T554 189Q616 189 655 236T694 338Q694 350 698 358T708 367Q722 367 722 334Q722 260 677 197T562 134H554Q517 134 481 152T414 196T355 248T292 293T223 311Q179 311 145 286Q109 257 96 218T80 156T69 133Q55 133 55 166Z"></path></g><g data-mml-node="msup" transform="translate(4022.5,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1378,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mo" transform="translate(6155.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(7155.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>, 其中<code>n</code>是该定义形式的位长度。因此，<code>i8</code>可存储数字范围是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="12.912ex" height="2.088ex" role="img" focusable="false" viewBox="0 -841 5707.1 923"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(778,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g></g><g data-mml-node="mo" transform="translate(1992.3,0)"><path data-c="223C" d="M55 166Q55 241 101 304T222 367Q260 367 296 349T362 304T421 252T484 208T554 189Q616 189 655 236T694 338Q694 350 698 358T708 367Q722 367 722 334Q722 260 677 197T562 134H554Q517 134 481 152T414 196T355 248T292 293T223 311Q179 311 145 286Q109 257 96 218T80 156T69 133Q55 133 55 166Z"></path></g><g data-mml-node="msup" transform="translate(3048.1,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g></g><g data-mml-node="mo" transform="translate(4206.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(5207.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>, 即 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="11.565ex" height="1.715ex" role="img" focusable="false" viewBox="0 -676 5111.6 758"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1000,0)"></path></g><g data-mml-node="mo" transform="translate(2555.8,0)"><path data-c="223C" d="M55 166Q55 241 101 304T222 367Q260 367 296 349T362 304T421 252T484 208T554 189Q616 189 655 236T694 338Q694 350 698 358T708 367Q722 367 722 334Q722 260 677 197T562 134H554Q517 134 481 152T414 196T355 248T292 293T223 311Q179 311 145 286Q109 257 96 218T80 156T69 133Q55 133 55 166Z"></path></g><g data-mml-node="mn" transform="translate(3611.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"></path></g></g></g></svg></mjx-container>。无符号类型可以存储的数字范围是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.324ex" height="1.714ex" role="img" focusable="false" viewBox="0 -675.5 4563.3 757.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="223C" d="M55 166Q55 241 101 304T222 367Q260 367 296 349T362 304T421 252T484 208T554 189Q616 189 655 236T694 338Q694 350 698 358T708 367Q722 367 722 334Q722 260 677 197T562 134H554Q517 134 481 152T414 196T355 248T292 293T223 311Q179 311 145 286Q109 257 96 218T80 156T69 133Q55 133 55 166Z"></path></g><g data-mml-node="msup" transform="translate(1833.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(3063,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4063.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>,所以<code>u8</code>能够存储的数字为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.164ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 4492.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="223C" d="M55 166Q55 241 101 304T222 367Q260 367 296 349T362 304T421 252T484 208T554 189Q616 189 655 236T694 338Q694 350 698 358T708 367Q722 367 722 334Q722 260 677 197T562 134H554Q517 134 481 152T414 196T355 248T292 293T223 311Q179 311 145 286Q109 257 96 218T80 156T69 133Q55 133 55 166Z"></path></g><g data-mml-node="msup" transform="translate(1833.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g></g><g data-mml-node="mo" transform="translate(2992.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(3992.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>,即<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="7.542ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 3333.6 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="223C" d="M55 166Q55 241 101 304T222 367Q260 367 296 349T362 304T421 252T484 208T554 189Q616 189 655 236T694 338Q694 350 698 358T708 367Q722 367 722 334Q722 260 677 197T562 134H554Q517 134 481 152T414 196T355 248T292 293T223 311Q179 311 145 286Q109 257 96 218T80 156T69 133Q55 133 55 166Z"></path></g><g data-mml-node="mn" transform="translate(1833.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"></path></g></g></g></svg></mjx-container>。</p>
<p>此外，<code>isize</code>和<code>usize</code>类型取决于程序运行的计算机CPU类型：若CPU是<code>32</code>位的，则这两个类型是<code>32</code>位的。</p>
</blockquote>
<p>整形字面值可以用下表的形式书写:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字字面值</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>十进制</td>
<td><code>98_222</code></td>
</tr>
<tr>
<td>十六进制</td>
<td><code>0xff</code></td>
</tr>
<tr>
<td>八进制</td>
<td><code>0o77</code></td>
</tr>
<tr>
<td>二进制</td>
<td><code>0b1111_0000</code></td>
</tr>
<tr>
<td>字节(仅限于<code>u8</code>)</td>
<td><code>b'A'</code></td>
</tr>
</tbody>
</table>
</div>
<p>这么多类型，有没有一个简单的使用准则？答案是肯定的， Rust 整型默认使用 <code>i32</code>，例如 <code>let i = 1</code>，那 <code>i</code>就是 <code>i32</code> 类型，因此你可以首选它，同时该类型也往往是性能最好的。<code>isize</code> 和 <code>usize</code> 的主要应用场景是用作集合的索引。</p>
<h4 id="整形溢出"><a href="#整形溢出" class="headerlink" title="整形溢出"></a>整形溢出</h4><p>假设有一个 <code>u8</code> ，它可以存放从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="7.542ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 3333.6 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="223C" d="M55 166Q55 241 101 304T222 367Q260 367 296 349T362 304T421 252T484 208T554 189Q616 189 655 236T694 338Q694 350 698 358T708 367Q722 367 722 334Q722 260 677 197T562 134H554Q517 134 481 152T414 196T355 248T292 293T223 311Q179 311 145 286Q109 257 96 218T80 156T69 133Q55 133 55 166Z"></path></g><g data-mml-node="mn" transform="translate(1833.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"></path></g></g></g></svg></mjx-container>的值。那么当你将其修改为范围之外的值，比如<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="3.394ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 1500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1000,0)"></path></g></g></g></svg></mjx-container>，则会发生整型溢出。关于这一行为Rust有一些有趣的规则：当在<code>debug</code>模式编译时，Rust会检查整型溢出，若存在这些问题，则使程序在编译时<code>panic</code>(崩溃,Rust使用这个术语来表明程序因错误而退出)。</p>
<p>在当使用<code>--release</code>参数进行<code>release</code>模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在<code>u8</code>的情况下，<code>256</code>变成<code>0</code>，<code>257</code>变成<code>1</code>，依此类推。程序不会<code>panic</code>，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。</p>
<p>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p>
<ul>
<li>使用<code>wrapping_*</code>方法在所有模式下都按照补码循环溢出规则处理，例如<code>wrapping_add</code></li>
<li>如果使用<code>checked_*</code>方法时发生溢出，则返回<code>None</code>值</li>
<li>使用<code>overflowing_*</code>方法返回该值和一个指示是否存在溢出的布尔值</li>
<li>使用<code>saturating_*</code>方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">100u8</span>.<span class="title function_ invoke__">saturating_add</span>(<span class="number">1</span>), <span class="number">101</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="type">u8</span>::MAX.<span class="title function_ invoke__">saturating_add</span>(<span class="number">127</span>), <span class="type">u8</span>::MAX);</span><br></pre></td></tr></table></figure>
<p>下面是<code>wrapping_*</code>的用法示例:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> : <span class="type">u8</span> = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">wrapping_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, b);  <span class="comment">// 19</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p><strong>浮点类型数字</strong>是带有小数点的数字，在Rust中浮点类型数字也有两种基本类型：<code>f32</code>和<code>f64</code>，分别为<code>32</code>位和<code>64</code>位大小。默认浮点类型是<code>f64</code>，在现代的CPU中它的速度与<code>f32</code>几乎相同，但精度更高。</p>
<p>下面是一个演示浮点数的示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>浮点数根据<code>IEEE-754</code>标准实现。<code>f32</code>类型是单精度浮点型，<code>f64</code>为双精度。</p>
<p>浮点数陷阱<br>浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：</p>
<ul>
<li>浮点数往往是你想要数字的近似表达 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如<code>0.1</code>在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行</li>
<li>浮点数在某些特性上是反直觉的 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用<code>&gt;</code>，<code>&gt;=</code>等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为<code>f32</code>，<code>f64</code>上的比较运算实现的是<code>std::cmp::PartialEq</code>特征(类似其他语言的接口)，但是并没有实现<code>std::cmp::Eq</code>特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：</li>
</ul>
<p>Rust的<code>HashMap</code>数据结构，是一个<code>KV</code>类型的<code>Hash Map</code>实现，它对于<code>K</code>没有特定类型的限制，但是要求能用作<code>K</code>的类型必须实现了<code>std::cmp::Eq</code>特征，因此这意味着你无法使用浮点数作为<code>HashMap</code>的<code>Key</code>，来存储键值对，但是作为对比,<code>Rust</code>的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为<code>HashMap</code>的<code>Key</code>。</p>
<p>为了避免上面说的两个陷阱，你需要遵守以下准则：</p>
<ul>
<li>避免在浮点数上测试相等性</li>
<li>当结果在数学上可能存在未定义时，需要格外的小心<br>来看个小例子:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 断言0.1 + 0.2与0.3相等</span></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>你可能以为，这段代码没啥问题吧，实际上它会<code>panic</code>（程序崩溃，抛出异常），因为二进制精度问题，导致了<code>0.1 + 0.2</code>并不严格等于<code>0.3</code>，它们可能在小数点<code>N</code>位后存在误差。</p>
<p>那如果非要进行比较呢？可以考虑用这种方式<code>(0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001</code>，具体小于多少，取决于你对精度的需求。</p>
<p>讲到这里，相信大家基本已经明白了，为什么操作浮点数时要格外的小心，但是还不够，下面再来一段代码，直接震撼你的灵魂：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">abc</span>: (<span class="type">f32</span>, <span class="type">f32</span>, <span class="type">f32</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">xyz</span>: (<span class="type">f64</span>, <span class="type">f64</span>, <span class="type">f64</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"abc (f32)"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"   0.1 + 0.2: {:x}"</span>, (abc.<span class="number">0</span> + abc.<span class="number">1</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"         0.3: {:x}"</span>, (abc.<span class="number">2</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"xyz (f64)"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"   0.1 + 0.2: {:x}"</span>, (xyz.<span class="number">0</span> + xyz.<span class="number">1</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"         0.3: {:x}"</span>, (xyz.<span class="number">2</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(abc.<span class="number">0</span> + abc.<span class="number">1</span> == abc.<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(xyz.<span class="number">0</span> + xyz.<span class="number">1</span> == xyz.<span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行该程序，输出如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">abc</span> (<span class="type">f32</span>)</span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span>: <span class="number">3e99999</span>a</span><br><span class="line"><span class="number">0.3</span>: <span class="number">3e99999</span>a</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">xyz</span> (<span class="type">f64</span>)</span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span>: <span class="number">3</span>fd3333333333334</span><br><span class="line"><span class="number">0.3</span>: <span class="number">3</span>fd3333333333333</span><br><span class="line"></span><br><span class="line">thread <span class="string">'main'</span> panicked at <span class="string">'assertion failed: xyz.0 + xyz.1 == xyz.2'</span>,</span><br><span class="line">➥ch2-add-floats.rs.rs:<span class="number">14</span>:<span class="number">5</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display</span><br><span class="line">➥a backtrace</span><br></pre></td></tr></table></figure>
<p>仔细看，对<code>f32</code>类型做加法时,<code>0.1 + 0.2</code>的结果是<code>3e99999a</code>，<code>0.3</code>也是<code>3e99999a</code>，因此<code>f32</code>下的<code>0.1 + 0.2 == 0.3</code>通过测试，但是到了<code>f64</code>类型时，结果就不一样了，因为<code>f64</code>精度高很多，因此在小数点非常后面发生了一点微小的变化,<code>0.1 + 0.2</code>以<code>4</code>结尾，但是<code>0.3</code>以<code>3</code>结尾，这个细微区别导致<code>f64</code>下的测试失败了，并且抛出了异常。</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>对于数学上未定义的结果，例如对负数取平方根<code>-42.1.sqrt()</code>，会产生一个特殊的结果：Rust 的浮点数类型使用<code>NaN</code>(not a number) 来处理这些情况。</p>
<p>所有跟<code>NaN</code>交互的操作，都会返回一个<code>NaN</code>，而且<code>NaN</code>不能用来比较，下面的代码会崩溃：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (-<span class="number">42.0_f32</span>).<span class="title function_ invoke__">sqrt</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, x);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>出于防御性编程的考虑，可以使用<code>is_nan()</code>等方法，可以用来判断一个数值是否是<code>NaN</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (-<span class="number">42.0_f32</span>).<span class="title function_ invoke__">sqrt</span>();</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">is_nan</span>() {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"未定义的数学行为"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h3><p>Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。下面代码各使用一条<code>let</code>语句来说明相应运算的用法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 加法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = <span class="number">5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">difference</span> = <span class="number">95.5</span> - <span class="number">4.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乘法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">product</span> = <span class="number">4</span> * <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotient</span> = <span class="number">56.7</span> / <span class="number">32.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求余</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">remainder</span> = <span class="number">43</span> % <span class="number">5</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这些语句中的每个表达式都使用了数学运算符，并且计算结果为一个值，然后绑定到一个变量上。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 编译器会进行自动推导，给予twenty i32的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">twenty</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 类型标注</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">twenty_one</span>: <span class="type">i32</span> = <span class="number">21</span>;</span><br><span class="line">    <span class="comment">// 通过类型后缀的方式进行类型标注：22是i32类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">twenty_two</span> = <span class="number">22i32</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 只有同样类型，才能运算</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">addition</span> = twenty + twenty_one + twenty_two;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{} + {} + {} = {}"</span>, twenty, twenty_one, twenty_two, addition);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 对于较长的数字，可以用_进行分割，提升可读性</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one_million</span>: <span class="type">i64</span> = <span class="number">1_000_000</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, one_million.<span class="title function_ invoke__">pow</span>(<span class="number">2</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义一个f32数组，其中42.0会自动被推导为f32类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">forty_twos</span> = [</span><br><span class="line">        <span class="number">42.0</span>,</span><br><span class="line">        <span class="number">42f32</span>,</span><br><span class="line">        <span class="number">42.0_f32</span>,</span><br><span class="line">    ];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 打印数组中第一个值，并控制小数位为2位</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:.2}"</span>, forty_twos[<span class="number">0</span>]);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>Rust 的位运算基本上和其他语言一样</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp; 位与</td>
<td>相同位置均为1时则为1，否则为0</td>
</tr>
<tr>
<td>位或</td>
<td>相同位置只要有1时则为1，否则为0</td>
</tr>
<tr>
<td>^ 异或</td>
<td>相同位置不相同则为1，相同则为0</td>
</tr>
<tr>
<td>! 位非</td>
<td>把位中的0和1相互取反，即0置为1，1置为0</td>
</tr>
<tr>
<td>&lt;&lt; 左移</td>
<td>所有位向左移动指定位数，右位补0</td>
</tr>
<tr>
<td>&gt;&gt; 右移</td>
<td>所有位向右移动指定位数，带符号移动（正数补0，负数补1）</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 无符号8位整数，二进制为00000010</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">u8</span> = <span class="number">2</span>; <span class="comment">// 也可以写 let a: u8 = 0b_0000_0010;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二进制为00000011</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u8</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// {:08b}：左高右低输出二进制01，不足8位则高位补0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a value is        {:08b}"</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b value is        {:08b}"</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"(a &amp; b) value is  {:08b}"</span>, a &amp; b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"(a | b) value is  {:08b}"</span>, a | b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"(a ^ b) value is  {:08b}"</span>, a ^ b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"(!b) value is     {:08b}"</span>, !b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"(a &lt;&lt; b) value is {:08b}"</span>, a &lt;&lt; b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"(a &gt;&gt; b) value is {:08b}"</span>, a &gt;&gt; b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = a;</span><br><span class="line">    <span class="comment">// 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)</span></span><br><span class="line">    a &lt;&lt;= b;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"(a &lt;&lt; b) value is {:08b}"</span>, a);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>Rust提供了一个非常简洁的方式，用来生成连续的数值，例如<code>1..5</code>，生成从<code>1</code>到<code>4</code>的连续数字，不包含<code>5</code>;<code>1..=5</code>，生成从<code>1</code>到<code>5</code>的连续数字，包含<code>5</code>，它的用途很简单，常常用于循环中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>,i);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>最终程序输出:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="string">'a'</span>..=<span class="string">'z'</span> {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>,i);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Rust中可以使用<code>As</code>来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型，但是它也可以完成诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针等功能。</p>
<h3 id="有理数和复数"><a href="#有理数和复数" class="headerlink" title="有理数和复数"></a>有理数和复数</h3><p>Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：</p>
<ul>
<li>有理数和复数</li>
<li>任意大小的整数和任意精度的浮点数</li>
<li>固定精度的十进制小数，常用于货币相关的场景</li>
</ul>
<p>好在社区已经开发出高质量的 Rust 数值库：<a href="https://crates.io/crates/num">num</a>。</p>
<p>按照以下步骤来引入<code>num</code>库：</p>
<ol>
<li>创建新工程 <code>cargo new complex-num &amp;&amp; cd complex-num</code></li>
<li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 下添加一行 <code>num = "0.4.0"</code></li>
<li>将 <code>src/main.rs</code> 文件中的 <code>main</code> 函数替换为下面的代码</li>
<li>运行 <code>cargo run</code></li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> num::complex::Complex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span> = Complex { re: <span class="number">2.1</span>, im: -<span class="number">1.2</span> };</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">b</span> = Complex::<span class="title function_ invoke__">new</span>(<span class="number">11.1</span>, <span class="number">22.2</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">result</span> = a + b;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">"{} + {}i"</span>, result.re, result.im)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-生命周期</title>
    <url>/2024/12/19/Rust-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>通过这篇博客深刻理解Rust的生命周期</p>
<span id="more"></span>]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>《古罗马文明的光芒》读书笔记</title>
    <url>/2024/12/19/%E3%80%8A%E5%8F%A4%E7%BD%97%E9%A9%AC%E6%96%87%E6%98%8E%E7%9A%84%E5%85%89%E8%8A%92%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《月亮与六便士》读书笔记</title>
    <url>/2024/12/19/%E3%80%8A%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>统计学习方法-02</title>
    <url>/2025/01/03/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-02/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>统计学习方法-01</title>
    <url>/2025/01/02/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-01/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习的一点感悟</title>
    <url>/2024/12/19/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
</search>
