<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 泛型编程</title>
    <url>/2024/12/19/C-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>这是一篇关于c++泛型编程的文章</p>
<span id="more"></span>
<p>Test</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 基本数据类型</title>
    <url>/2024/12/19/Rust-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Rust-基本数据类型概述"><a href="#Rust-基本数据类型概述" class="headerlink" title="Rust 基本数据类型概述"></a>Rust 基本数据类型概述</h1><p>Rust 每个值都有确切的数据类型, 总的来说可以分为两类: 借本类型和复合类型。基本类型意味着它们往往是一个最小化原子类型，无法结构为其它类型。</p>
<span id="more"></span>
<p>一般来说Rust包含以下基本类型:</p>
<ul>
<li>数值类型: 有符号整数(<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、无符号整数(<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>)</li>
<li>字符串: 字符串字面量和字符串切片 <code>&amp;str</code></li>
<li>布尔类型: <code>true</code> 和 <code>false</code></li>
<li>字符类型: 表示单个Unicode字符，存储为四个字节</li>
<li>单元类型: 即<code>()</code>, 其唯一的值也是()</li>
</ul>
<h1 id="类型推导与标注"><a href="#类型推导与标注" class="headerlink" title="类型推导与标注"></a>类型推导与标注</h1><p>与Python、JavaScript等动态语言不同，Rust是一门静态类型语言，也就是编译器必须再编译期知道所有变量的类型，但这不意味着你需要为每个变量指定类型，因为<strong>Rust编译器可以根据变量值和上下文的使用方式来自动推导出变量的类型</strong>，但在某些情况下，它无法推导出变量类型，需要手动去给与一个类型标注。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span> = <span class="string">&quot;32&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">except</span>(<span class="string">&quot;Not a number!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上述代码编译器无法推导出想要的类型，编译器给出如下报错:<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[Running] cargo run -q --release <span class="string">&quot;i:\SourceCode\Rust\data_deep\src\main.rs&quot;</span></span><br><span class="line">error[E0284]: <span class="keyword">type</span> <span class="title class_">annotations</span> needed</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">2</span>:<span class="number">9</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |     <span class="keyword">let</span> <span class="variable">guess</span> = <span class="string">&quot;32&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;not a number&quot;</span>);</span><br><span class="line">  |         ^^^^^        ----- <span class="keyword">type</span> <span class="title class_">must</span> be known at this point</span><br><span class="line">  |</span><br><span class="line">  = note: cannot satisfy `&lt;_ <span class="keyword">as</span> FromStr&gt;::<span class="literal">Err</span> == _`</span><br><span class="line">help: consider giving `guess` an explicit <span class="keyword">type</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |     <span class="keyword">let</span> <span class="variable">guess</span>: <span class="comment">/* Type */</span> = <span class="string">&quot;32&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;not a number&quot;</span>);</span><br><span class="line">  |              ++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0284`.</span><br><span class="line">error: could not compile `data_deep` (bin <span class="string">&quot;data_deep&quot;</span>) due to <span class="number">1</span> previous error</span><br><span class="line"></span><br><span class="line">[Done] exited with code=<span class="number">101</span> <span class="keyword">in</span> <span class="number">0.605</span> seconds</span><br></pre></td></tr></table></figure></p>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><blockquote>
<p>Rust使用一种相对传统的语法来创建整数<code>(1, 2, ...)</code>和浮点数<code>(1.0, 1.1, ...)</code>.</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整数是没有小数的数字，<code>i</code>是<code>integer</code>的首字母，<code>u</code>是<code>unsigned</code>的首字母</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号整形</th>
<th>无符号整形</th>
</tr>
</thead>
<tbody>
<tr>
<td>8位</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16位</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32位</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64位</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128位</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>视架构而定</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody>
</table>
</div>
<p>类型定义的形式统一为:<code>i(u)+类型位数</code>。<strong>无符号数</strong>表示只能取正整数和0，而<strong>有符号数</strong>则表示数字可以取正整数、负整数和0。</p>
<blockquote>
<p>每个有符号类型规定的数字范围是$-2^{n-1}\sim2^{n-1} -1$, 其中<code>n</code>是该定义形式的位长度。因此，<code>i8</code>可存储数字范围是$-2^7\sim2^7-1$, 即 $-128\sim127$。无符号类型可以存储的数字范围是$0\sim2^n-1$,所以<code>u8</code>能够存储的数字为$0\sim2^8-1$,即$0\sim255$。</p>
<p>此外，<code>isize</code>和<code>usize</code>类型取决于程序运行的计算机CPU类型：若CPU是<code>32</code>位的，则这两个类型是<code>32</code>位的。</p>
</blockquote>
<p>整形字面值可以用下表的形式书写:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字字面值</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>十进制</td>
<td><code>98_222</code></td>
</tr>
<tr>
<td>十六进制</td>
<td><code>0xff</code></td>
</tr>
<tr>
<td>八进制</td>
<td><code>0o77</code></td>
</tr>
<tr>
<td>二进制</td>
<td><code>0b1111_0000</code></td>
</tr>
<tr>
<td>字节(仅限于<code>u8</code>)</td>
<td><code>b&#39;A&#39;</code></td>
</tr>
</tbody>
</table>
</div>
<p>这么多类型，有没有一个简单的使用准则？答案是肯定的， Rust 整型默认使用 <code>i32</code>，例如 <code>let i = 1</code>，那 <code>i</code>就是 <code>i32</code> 类型，因此你可以首选它，同时该类型也往往是性能最好的。<code>isize</code> 和 <code>usize</code> 的主要应用场景是用作集合的索引。</p>
<h4 id="整形溢出"><a href="#整形溢出" class="headerlink" title="整形溢出"></a>整形溢出</h4><p>假设有一个 <code>u8</code> ，它可以存放从$0\sim255$的值。那么当你将其修改为范围之外的值，比如$256$，则会发生整型溢出。关于这一行为Rust有一些有趣的规则：当在<code>debug</code>模式编译时，Rust会检查整型溢出，若存在这些问题，则使程序在编译时<code>panic</code>(崩溃,Rust使用这个术语来表明程序因错误而退出)。</p>
<p>在当使用<code>--release</code>参数进行<code>release</code>模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在<code>u8</code>的情况下，<code>256</code>变成<code>0</code>，<code>257</code>变成<code>1</code>，依此类推。程序不会<code>panic</code>，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。</p>
<p>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p>
<p>使用<code>wrapping_*</code>方法在所有模式下都按照补码循环溢出规则处理，例如<code>wrapping_add</code><br>如果使用<code>checked_*</code>方法时发生溢出，则返回<code>None</code>值<br>使用<code>overflowing_*</code>方法返回该值和一个指示是否存在溢出的布尔值<br>使用<code>saturating_*</code>方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">100u8</span>.<span class="title function_ invoke__">saturating_add</span>(<span class="number">1</span>), <span class="number">101</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="type">u8</span>::MAX.<span class="title function_ invoke__">saturating_add</span>(<span class="number">127</span>), <span class="type">u8</span>::MAX);</span><br></pre></td></tr></table></figure><br>下面是<code>wrapping_*</code>的用法示例:<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> : <span class="type">u8</span> = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">wrapping_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);  <span class="comment">// 19</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><h3 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h3><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h3 id="有理数和复数"><a href="#有理数和复数" class="headerlink" title="有理数和复数"></a>有理数和复数</h3>]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 所有权机制</title>
    <url>/2024/12/19/Rust-%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>通过这篇博客深刻理解Rust的所有权机制</p>
<span id="more"></span>]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-生命周期</title>
    <url>/2024/12/19/Rust-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>通过这篇博客深刻理解Rust的生命周期</p>
<span id="more"></span>]]></content>
  </entry>
  <entry>
    <title>《你当像鸟飞向你的山》读书笔记</title>
    <url>/2024/12/19/%E3%80%8A%E4%BD%A0%E5%BD%93%E5%83%8F%E9%B8%9F%E9%A3%9E%E5%90%91%E4%BD%A0%E7%9A%84%E5%B1%B1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《古罗马文明的光芒》读书笔记</title>
    <url>/2024/12/19/%E3%80%8A%E5%8F%A4%E7%BD%97%E9%A9%AC%E6%96%87%E6%98%8E%E7%9A%84%E5%85%89%E8%8A%92%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《月亮与六便士》读书笔记</title>
    <url>/2024/12/19/%E3%80%8A%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
